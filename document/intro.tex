\section{Introduction} \label{sec:intro}
Control law diagrams such as Simulink~\cite{Simulink} and OpenModelica~\cite{openmodelica} are widely used industrial languages and tool-sets for expressing control laws, including support for simulation and code generation. In particular, Simulink actually is a \emph{de facto} standard in many areas in industry. Its model based design, simulation and code generation make it a very efficient and cost-effective way to develop complex systems. Though empirical analysis through simulation is an important technique to explore and refine models, only formal verification can make specific mathematical guarantees about behaviour, which is crucial to ensure safety of associated implementations. Whilst verification facilities for Simulink exist~\cite{Arthan2000, Roy2011, Bostroem2016, Caspi2003, Cavalcanti2005a, Preoteasa2017}, there is still a need for assertional reasoning techniques that capture the full range of specifiable behaviour, provide non-deterministic specification constructs, and support compositional verification. Such techniques also need to be sufficiently expressive to handle the plethora of additional languages and modelling notations that are used by industry in concert with Simulink, in order to allow formulation of heterogeneous "multi-models" that capture the different paradigms and disciplines used in large scale systems~\cite{Zeyda2018}. Applicable tool support for these techniques with a high degree of automation is also of vital importance to enable adoption by industry. Since Simulink diagrams are data rich and usually have an uncountably infinite state space, model checking alone is insufficient and there is a need for theorem proving facilities.

Assume-Guarantee (AG) reasoning is a valuable compositional verification technique for reactive systems~\cite{Meyer1992, Jones2003, Bauer2012}. In AG, one demonstrates composite system level properties by decomposing them into a number of contracts for each component subsystem. Each contract specifies the guarantees that the subsystem will make about its behaviour, under certain specified assumptions of the subsystem's environment. Such a decomposition is vital in order to make verification of a complex system tractable, and to allow development of subsystems by separate teams. AG reasoning has previously been applied to verification of discrete time Simulink control law diagrams through mappings into synchronous languages like Lustre~\cite{Tripakis2005} and Kahn Process Networks~\cite{Bostroem2016}. However such formalisms, whilst theoretically and practically appealing, are limited to expressing processes that are inherently deterministic and non-terminating in nature. Refinement Calculus for Reactive Systems (RCRS)~\cite{Preoteasa2017} is a methodology that can be applied to reason about non-deterministic and non-input-receptive systems by treating programs as predicate transformers. However, it is not able to reason about multi-rate Simulink diagrams and algebraic loops. Almost all these verification facilities translate Simulink to sequential languages, synchronous languages or reactive languages~\cite{Cavalcanti2005a}, and then use verification methods for these languages to reason about Simulink diagrams. There is a need to develop a reasoning technique that is based on the semantic understanding of simulation in Simulink as described in Section~\ref{ssec:simulink}. Thus, it is necessary to translate to several additional notations where AG verification can be performed, which hampers both traceability and composition with other languages of different paradigms. What is needed is a rich unified language capable of AG reasoning, and supported by theorem proving, into which Simulink and associated notations can be losslessly translated.

Our proposed approach thus explores development of formal AG-based proof support for discrete-time Simulink diagrams through a semantic embedding of the theory of designs~\cite{Woodcock2004} in Unifying Theories of Programming (UTP)~\cite{Hoare1998} in Isabelle/HOL~\cite{Nipkow2002} using our developed tool Isabelle/UTP~\cite{Foster2014}. Initially, we proposed to use \Circus~\cite{Oliveira2009}, a formal modelling language for concurrent and reactive systems in the style of CSP, to model Simulink diagrams as shown in~\cite{Cavalcanti2005a}, and then apply contract-based reasoning to \Circus. A \Circus\ model consists of a network of processes that communicate with one another solely via shared channels that carry typed data. Internal state variables are encapsulated and not directly observable by other parallel processes. \Circus\ can capture a variety of languages at the semantic level, and thus supports the formulation of heterogeneous multi-models~\cite{Zeyda2018} by acting as a ``lingua franca''. In addition, a timed version of \Circus\ is used to model multi-rate diagrams. However, a \Circus\ model has more complex information of blocks in Simulink for AG reasoning. For example, the corresponding \Circus\ process for a block uses channels to model connections in diagrams, a non-deterministic internal choice of all input channels to allow an arbitrary input order, and similarly an internal choice of output channels to allow an arbitrary output order. 

In order to reason about the \Circus\ model, we need to take trace information into account and traces inevitably are more complicated if there are many inputs and outputs for a block. Eventually, using model checking or theorem proving to verify \Circus\ models becomes more difficult. According to the semantic understanding of simulation in Simulink in Section~\ref{ssec:simulink}, actually the order of inputs and outputs is irrelevant. Therefore, we have changed our approach to use the theory of designs in UTP to enable AG reasoning for Simulink block diagrams. 

A \emph{design} in UTP is a relation between two predicates where the first predicate (precondition) records the assumption and the second one (postcondition) specifies the commitment. \emph{Designs} are intrinsically suitable for modelling and reasoning about state-based programs (such as B machines~\cite{Abrial2005} and Z notations~\cite{Spivey1989}) but not necessary for reactive programs. For simulation of Simulink diagrams, we discretise the simulation time and abstract it into steps (natural numbers), and define inputs and outputs of Simulink blocks as a function from step numbers to a list of inputs or outputs. In this way, the reactive behaviour is encoded in the step numbers in functions. Finally, the theory of designs can be used to reason about reactive behaviour of Simulink diagrams without introduction of detailed implementation information .

Our work presented in this report has multiple contributions. The main contribution is to define a theoretical reasoning framework for control law block diagrams using the theory of designs in UTP. Each block or subsystem is translated to a design and then hierarchical connections of blocks are mapped to a variety of compositions of designs. Additionally, the refinement relation of designs, monotony of composition operators, and closure laws enable compositional reasoning of block diagrams using a contract-based methodology. The second contribution is our mechanisation of theories in the theorem prover Isabelle using our implementation of UTP, Isabelle/UTP. Then the practical contribution is our industrial case study of a subsystem in a safety critical aircraft cabin pressure control system.

In the next section, we describe the relevant preliminary background about Simulink and UTP. Then in Section~\ref{sec:assum}, the assumptions we made are presented and a brief reasoning procedure is described. Section~\ref{sec:trans} defines our treatment of blocks in UTP and translations of a number of blocks are illustrated. Furthermore, we introduce our composition operators and their corresponding theorems in Section~\ref{sec:comp}. Afterwards, in Section~\ref{sec:case} we briefly describe the industrial case study. And we conclude our work in Section~\ref{sec:conclu}. Additionally, our mechanised theories, laws and case studies are attached in appendices.
